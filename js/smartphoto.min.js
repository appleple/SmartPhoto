(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.SmartPhoto = factory());
})(this, function() {
  "use strict";
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        var isInstance = false;
        try {
          isInstance = this instanceof a2;
        } catch {
        }
        if (isInstance) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var lib = { exports: {} };
  var ieArrayFindPolyfill = {};
  var hasRequiredIeArrayFindPolyfill;
  function requireIeArrayFindPolyfill() {
    if (hasRequiredIeArrayFindPolyfill) return ieArrayFindPolyfill;
    hasRequiredIeArrayFindPolyfill = 1;
    if (!Array.prototype.find) {
      Object.defineProperty(Array.prototype, "find", {
        value: function(predicate) {
          if (this == null) {
            throw new TypeError("this is null or not defined");
          }
          var obj = Object(this);
          var len = obj.length >>> 0;
          if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
          }
          var thisArg = arguments[1];
          var index = 0;
          while (index < len) {
            var iValue = obj[index];
            if (predicate.call(thisArg, iValue, index, obj)) {
              return iValue;
            }
            index++;
          }
          return void 0;
        }
      });
    }
    return ieArrayFindPolyfill;
  }
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template2 = doc.createElement("template");
    template2.innerHTML = str;
    return template2.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    if (fromNodeName === toNodeName) {
      return true;
    }
    if (toEl.actualize && fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */
    toNodeName.charCodeAt(0) > 90) {
      return fromNodeName === toNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            }
          }
          handleNodeAdded(curChild);
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(
              curFromNodeChild,
              fromEl,
              true
              /* skip keyed nodes */
            );
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer: while (curToNodeChild) {
          toNextSibling = curToNodeChild.nextSibling;
          curToNodeKey = getNodeKey(curToNodeChild);
          while (curFromNodeChild) {
            fromNextSibling = curFromNodeChild.nextSibling;
            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
              curToNodeChild = toNextSibling;
              curFromNodeChild = fromNextSibling;
              continue outer;
            }
            curFromNodeKey = getNodeKey(curFromNodeChild);
            var curFromNodeType = curFromNodeChild.nodeType;
            var isCompatible = void 0;
            if (curFromNodeType === curToNodeChild.nodeType) {
              if (curFromNodeType === ELEMENT_NODE) {
                if (curToNodeKey) {
                  if (curToNodeKey !== curFromNodeKey) {
                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                      if (fromNextSibling === matchingFromEl) {
                        isCompatible = false;
                      } else {
                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                        if (curFromNodeKey) {
                          addKeyedRemoval(curFromNodeKey);
                        } else {
                          removeNode(
                            curFromNodeChild,
                            fromEl,
                            true
                            /* skip keyed nodes */
                          );
                        }
                        curFromNodeChild = matchingFromEl;
                      }
                    } else {
                      isCompatible = false;
                    }
                  }
                } else if (curFromNodeKey) {
                  isCompatible = false;
                }
                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                if (isCompatible) {
                  morphEl(curFromNodeChild, curToNodeChild);
                }
              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                isCompatible = true;
                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                }
              }
            }
            if (isCompatible) {
              curToNodeChild = toNextSibling;
              curFromNodeChild = fromNextSibling;
              continue outer;
            }
            if (curFromNodeKey) {
              addKeyedRemoval(curFromNodeKey);
            } else {
              removeNode(
                curFromNodeChild,
                fromEl,
                true
                /* skip keyed nodes */
              );
            }
            curFromNodeChild = fromNextSibling;
          }
          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
            fromEl.appendChild(matchingFromEl);
            morphEl(matchingFromEl, curToNodeChild);
          } else {
            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
            if (onBeforeNodeAddedResult !== false) {
              if (onBeforeNodeAddedResult) {
                curToNodeChild = onBeforeNodeAddedResult;
              }
              if (curToNodeChild.actualize) {
                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
              }
              fromEl.appendChild(curToNodeChild);
              handleNodeAdded(curToNodeChild);
            }
          }
          curToNodeChild = toNextSibling;
          curFromNodeChild = fromNextSibling;
        }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  const morphdomEsm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: morphdom
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(morphdomEsm);
  var util = {};
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil) return util;
    hasRequiredUtil = 1;
    Object.defineProperty(util, "__esModule", {
      value: true
    });
    var matches = util.matches = function matches2(element, query) {
      var matches3 = (element.document || element.ownerDocument).querySelectorAll(query);
      var i = matches3.length;
      while (--i >= 0 && matches3.item(i) !== element) {
      }
      return i > -1;
    };
    util.selector = function selector(_selector) {
      return document.querySelector(_selector);
    };
    var findAncestor = util.findAncestor = function findAncestor2(element, selector) {
      if (typeof element.closest === "function") {
        return element.closest(selector) || null;
      }
      while (element && element !== document) {
        if (matches(element, selector)) {
          return element;
        }
        element = element.parentElement;
      }
      return null;
    };
    var listenerList = [];
    util.on = function on(element, query, eventNames, fn) {
      var capture = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var events = eventNames.split(" ");
      events.forEach(function(event2) {
        var listener = function listener2(e) {
          var delegateTarget = findAncestor(e.target, query);
          if (delegateTarget) {
            e.delegateTarget = delegateTarget;
            fn(e);
          }
        };
        listenerList.push({ listener, element, query, event: event2, capture });
        element.addEventListener(event2, listener, capture);
      });
    };
    util.off = function off(element, query, eventNames) {
      var events = eventNames.split(" ");
      events.forEach(function(event2) {
        listenerList.forEach(function(item, index) {
          if (item.element === element && item.query === query && item.event === event2) {
            element.removeEventListener(event2, item.listener, item.capture);
            listenerList.splice(index, 1);
          }
        });
      });
    };
    return util;
  }
  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib) return lib.exports;
    hasRequiredLib = 1;
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      var _createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      requireIeArrayFindPolyfill();
      var _morphdom = require$$1;
      var _morphdom2 = _interopRequireDefault(_morphdom);
      var _util = requireUtil();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var eventType = "input paste copy click change keydown keyup keypress contextmenu mouseup mousedown mousemove touchstart touchend touchmove compositionstart compositionend focus";
      var bindType = "input change click";
      var dataAction = eventType.replace(/([a-z]+)/g, "[data-action-$1],") + "[data-action]";
      var aTemplate = function() {
        function aTemplate2(opt) {
          var _this = this;
          _classCallCheck(this, aTemplate2);
          this.atemplate = [];
          this.events = [];
          if (opt) {
            Object.keys(opt).forEach(function(key) {
              _this[key] = opt[key];
            });
          }
          if (!this.data) {
            this.data = {};
          }
          if (!this.templates) {
            this.templates = [];
          }
          var templates = this.templates;
          var length = templates.length;
          for (var i = 0, n = length; i < n; i += 1) {
            var template2 = this.templates[i];
            var html = (0, _util.selector)("#" + template2).innerHTML;
            this.atemplate.push({ id: template2, html, binded: false });
          }
        }
        _createClass(aTemplate2, [{
          key: "addDataBind",
          value: function addDataBind(ele) {
            var _this2 = this;
            (0, _util.on)(ele, "[data-bind]", bindType, function(e) {
              var target = e.delegateTarget;
              var data = target.getAttribute("data-bind");
              var attr = target.getAttribute("href");
              var value = target.value;
              if (attr) {
                value = value.replace("#", "");
              }
              if (target.getAttribute("type") === "checkbox") {
                (function() {
                  var arr = [];
                  var items = document.querySelectorAll('[data-bind="' + data + '"]');
                  [].forEach.call(items, function(item) {
                    if (item.checked) {
                      arr.push(item.value);
                    }
                  });
                })();
              } else if (target.getAttribute("type") !== "radio") {
                _this2.updateDataByString(data, value);
              }
            });
            this.events.push({
              element: ele,
              selector: "[data-bind]",
              event: bindType
            });
          }
        }, {
          key: "addActionBind",
          value: function addActionBind(ele) {
            var _this3 = this;
            (0, _util.on)(ele, dataAction, eventType, function(e) {
              var target = e.delegateTarget;
              var events = eventType.split(" ");
              var action = "action";
              events.forEach(function(event2) {
                if (target.getAttribute("data-action-" + event2)) {
                  if (e.type === event2) {
                    action += "-" + event2;
                  }
                }
              });
              var string = target.getAttribute("data-" + action);
              if (!string) {
                return;
              }
              var method = string.replace(/\(.*?\);?/, "");
              var parameter = string.replace(/(.*?)\((.*?)\);?/, "$2");
              var pts = parameter.split(",");
              _this3.e = e;
              if (_this3.method && _this3.method[method]) {
                var _method;
                (_method = _this3.method)[method].apply(_method, _toConsumableArray(pts));
              } else if (_this3[method]) {
                _this3[method].apply(_this3, _toConsumableArray(pts));
              }
            });
            this.events.push({
              element: ele,
              selector: dataAction,
              event: bindType
            });
          }
        }, {
          key: "removeTemplateEvents",
          value: function removeTemplateEvents() {
            this.events.forEach(function(event2) {
              (0, _util.off)(event2.element, event2.selector, event2.event);
            });
          }
        }, {
          key: "addTemplate",
          value: function addTemplate(id, html) {
            this.atemplate.push({ id, html, binded: false });
            this.templates.push(id);
          }
          // loadHtml() {
          //   const templates = this.templates;
          //   const promises = [];
          //   templates.forEach((template) => {
          //     const d = new $.Deferred();
          //     promises.push(d);
          //     const src = selector(`#${template}`).getAttribute('src');
          //     $.ajax({
          //       url: src,
          //       type: 'GET',
          //       dataType: 'text'
          //     }).success((data) => {
          //       selector(`#${template}`).innerHTML = data;
          //       d.resolve();
          //     });
          //   });
          //   return $.when(...promises);
          // }
        }, {
          key: "getData",
          value: function getData() {
            return JSON.parse(JSON.stringify(this.data));
          }
        }, {
          key: "saveData",
          value: function saveData(key) {
            var data = JSON.stringify(this.data);
            localStorage.setItem(key, data);
          }
        }, {
          key: "setData",
          value: function setData(opt) {
            var _this4 = this;
            Object.keys(opt).forEach(function(key) {
              if (typeof opt[key] !== "function") {
                _this4.data[key] = opt[key];
              }
            });
          }
        }, {
          key: "loadData",
          value: function loadData(key) {
            var data = JSON.parse(localStorage.getItem(key));
            if (data) {
              this.setData(data);
            }
          }
        }, {
          key: "getRand",
          value: function getRand(a, b) {
            return ~~(Math.random() * (b - a + 1)) + a;
          }
        }, {
          key: "getRandText",
          value: function getRandText(limit) {
            var ret = "";
            var strings = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            var length = strings.length;
            for (var i = 0; i < limit; i += 1) {
              ret += strings.charAt(Math.floor(this.getRand(0, length)));
            }
            return ret;
          }
        }, {
          key: "getDataFromObj",
          value: function getDataFromObj(s, o) {
            s = s.replace(/\[([\w\-\.ぁ-んァ-ヶ亜-熙]+)\]/g, ".$1");
            s = s.replace(/^\./, "");
            var a = s.split(".");
            while (a.length) {
              var n = a.shift();
              if (n in o) {
                o = o[n];
              } else {
                return null;
              }
            }
            return o;
          }
        }, {
          key: "getDataByString",
          value: function getDataByString(s) {
            var o = this.data;
            return this.getDataFromObj(s, o);
          }
        }, {
          key: "updateDataByString",
          value: function updateDataByString(path, newValue) {
            var object = this.data;
            var stack = path.split(".");
            while (stack.length > 1) {
              object = object[stack.shift()];
            }
            object[stack.shift()] = newValue;
          }
        }, {
          key: "removeDataByString",
          value: function removeDataByString(path) {
            var object = this.data;
            var stack = path.split(".");
            while (stack.length > 1) {
              object = object[stack.shift()];
            }
            var shift = stack.shift();
            if (shift.match(/^\d+$/)) {
              object.splice(Number(shift), 1);
            } else {
              delete object[shift];
            }
          }
        }, {
          key: "resolveBlock",
          value: function resolveBlock(html, item, i) {
            var that = this;
            var touchs = html.match(/<!-- BEGIN ([\w\-\.ぁ-んァ-ヶ亜-熙]+):touch#([\w\-\.ぁ-んァ-ヶ亜-熙]+) -->/g);
            var touchnots = html.match(/<!-- BEGIN ([\w\-\.ぁ-んァ-ヶ亜-熙]+):touchnot#([\w\-\.ぁ-んァ-ヶ亜-熙]+) -->/g);
            var exists = html.match(/<!-- BEGIN ([\w\-\.ぁ-んァ-ヶ亜-熙]+):exist -->/g);
            var empties = html.match(/<!-- BEGIN ([\w\-\.ぁ-んァ-ヶ亜-熙]+):empty -->/g);
            if (touchs) {
              for (var k = 0, n = touchs.length; k < n; k += 1) {
                var start = touchs[k];
                start = start.replace(/([\w\-\.ぁ-んァ-ヶ亜-熙]+):touch#([\w\-\.ぁ-んァ-ヶ亜-熙]+)/, "($1):touch#($2)");
                var end = start.replace(/BEGIN/, "END");
                var reg = new RegExp(start + "(([\\n\\r\\t]|.)*?)" + end, "g");
                html = html.replace(reg, function(m, key2, val, next) {
                  var itemkey = typeof item[key2] === "function" ? item[key2].apply(that) : that.getDataFromObj(key2, item);
                  if ("" + itemkey === val) {
                    return next;
                  }
                  return "";
                });
              }
            }
            if (touchnots) {
              for (var _k = 0, _n = touchnots.length; _k < _n; _k += 1) {
                var _start = touchnots[_k];
                _start = _start.replace(/([\w\-\.ぁ-んァ-ヶ亜-熙]+):touchnot#([\w\-\.ぁ-んァ-ヶ亜-熙]+)/, "($1):touchnot#($2)");
                var _end = _start.replace(/BEGIN/, "END");
                var _reg = new RegExp(_start + "(([\\n\\r\\t]|.)*?)" + _end, "g");
                html = html.replace(_reg, function(m, key2, val, next) {
                  var itemkey = typeof item[key2] === "function" ? item[key2].apply(that) : that.getDataFromObj(key2, item);
                  if ("" + itemkey !== val) {
                    return next;
                  }
                  return "";
                });
              }
            }
            if (exists) {
              for (var _k2 = 0, _n2 = exists.length; _k2 < _n2; _k2 += 1) {
                var _start2 = exists[_k2];
                _start2 = _start2.replace(/([\w\-\.ぁ-んァ-ヶ亜-熙]+):exist/, "($1):exist");
                var _end2 = _start2.replace(/BEGIN/, "END");
                var _reg2 = new RegExp(_start2 + "(([\\n\\r\\t]|.)*?)" + _end2, "g");
                html = html.replace(_reg2, function(m, key2, next) {
                  var itemkey = typeof item[key2] === "function" ? item[key2].apply(that) : that.getDataFromObj(key2, item);
                  if (itemkey || itemkey === 0) {
                    return next;
                  }
                  return "";
                });
              }
            }
            if (empties) {
              for (var _k3 = 0, _n3 = empties.length; _k3 < _n3; _k3 += 1) {
                var _start3 = empties[_k3];
                _start3 = _start3.replace(/([\w\-\.ぁ-んァ-ヶ亜-熙]+):empty/, "($1):empty");
                var _end3 = _start3.replace(/BEGIN/, "END");
                var empty = new RegExp(_start3 + "(([\\n\\r\\t]|.)*?)" + _end3, "g");
                html = html.replace(empty, function(m, key2, next) {
                  var itemkey = typeof item[key2] === "function" ? item[key2].apply(that) : that.getDataFromObj(key2, item);
                  if (!itemkey && itemkey !== 0) {
                    return next;
                  }
                  return "";
                });
              }
            }
            html = html.replace(/{([\w\-\.ぁ-んァ-ヶ亜-熙]+)}(\[([\w\-\.ぁ-んァ-ヶ亜-熙]+)\])*/g, function(n2, key3, key4, converter) {
              var data = void 0;
              if ("" + key3 === "i") {
                data = i;
              } else if (item[key3] || item[key3] === 0) {
                if (typeof item[key3] === "function") {
                  data = item[key3].apply(that);
                } else {
                  data = item[key3];
                }
              } else {
                if (converter && that.convert && that.convert[converter]) {
                  return that.convert[converter].call(that, "");
                }
                return "";
              }
              if (converter && that.convert && that.convert[converter]) {
                return that.convert[converter].call(that, data);
              }
              return data;
            });
            return html;
          }
          /* 絶対パス形式の変数を解決*/
        }, {
          key: "resolveAbsBlock",
          value: function resolveAbsBlock(html) {
            var that = this;
            html = html.replace(/{(.*?)}/g, function(n, key3) {
              var data = that.getDataByString(key3);
              if (typeof data !== "undefined") {
                if (typeof data === "function") {
                  return data.apply(that);
                }
                return data;
              }
              return n;
            });
            return html;
          }
        }, {
          key: "resolveInclude",
          value: function resolveInclude(html) {
            var include = /<!-- #include id="(.*?)" -->/g;
            html = html.replace(include, function(m, key) {
              return (0, _util.selector)("#" + key).innerHTML;
            });
            return html;
          }
        }, {
          key: "resolveWith",
          value: function resolveWith(html) {
            var width = /<!-- BEGIN ([\w\-\.ぁ-んァ-ヶ亜-熙]+):with -->(([\n\r\t]|.)*?)<!-- END ([\w\-\.ぁ-んァ-ヶ亜-熙]+):with -->/g;
            html = html.replace(width, function(m, key) {
              m = m.replace(/data\-bind=['"](.*?)['"]/g, "data-bind='" + key + ".$1'");
              return m;
            });
            return html;
          }
        }, {
          key: "resolveLoop",
          value: function resolveLoop(html) {
            var loop = /<!-- BEGIN ([\w\-\.ぁ-んァ-ヶ亜-熙]+?):loop -->(([\n\r\t]|.)*?)<!-- END ([\w\-\.ぁ-んァ-ヶ亜-熙]+?):loop -->/g;
            var that = this;
            html = html.replace(loop, function(m, key, val) {
              var keyItem = that.getDataByString(key);
              var keys = [];
              if (typeof keyItem === "function") {
                keys = keyItem.apply(that);
              } else {
                keys = keyItem;
              }
              var ret = "";
              if (keys instanceof Array) {
                for (var i = 0, n = keys.length; i < n; i += 1) {
                  ret += that.resolveBlock(val, keys[i], i);
                }
              }
              ret = ret.replace(/\\([^\\])/g, "$1");
              return ret;
            });
            return html;
          }
        }, {
          key: "removeData",
          value: function removeData(arr) {
            var data = this.data;
            Object.keys(data).forEach(function(i) {
              for (var t = 0, n = arr.length; t < n; t += 1) {
                if (i === arr[t]) {
                  delete data[i];
                }
              }
            });
            return this;
          }
        }, {
          key: "hasLoop",
          value: function hasLoop(txt) {
            var loop = /<!-- BEGIN ([\w\-\.ぁ-んァ-ヶ亜-熙]+?):loop -->(([\n\r\t]|.)*?)<!-- END ([\w\-\.ぁ-んァ-ヶ亜-熙]+?):loop -->/g;
            if (txt.match(loop)) {
              return true;
            }
            return false;
          }
        }, {
          key: "getHtml",
          value: function getHtml(query, row) {
            var template2 = this.atemplate.find(function(item) {
              return item.id === query;
            });
            var html = "";
            if (template2 && template2.html) {
              html = template2.html;
            }
            if (row) {
              html = query;
            }
            if (!html) {
              return "";
            }
            var data = this.data;
            html = this.resolveInclude(html);
            html = this.resolveWith(html);
            while (this.hasLoop(html)) {
              html = this.resolveLoop(html);
            }
            html = this.resolveBlock(html, data);
            html = html.replace(/\\([^\\])/g, "$1");
            html = this.resolveAbsBlock(html);
            return html.replace(/^([\t ])*\n/gm, "");
          }
        }, {
          key: "update",
          value: function update() {
            var _this5 = this;
            var renderWay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "html";
            var part = arguments[1];
            var templates = this.templates;
            if (this.beforeUpdated) {
              this.beforeUpdated();
            }
            var _loop = function _loop2(i2, n2) {
              var tem = templates[i2];
              var query = "#" + tem;
              var html = _this5.getHtml(tem);
              var target = (0, _util.selector)("[data-id='" + tem + "']");
              if (!target) {
                (0, _util.selector)(query).insertAdjacentHTML("afterend", '<div data-id="' + tem + '"></div>');
                if (renderWay === "text") {
                  (0, _util.selector)("[data-id='" + tem + "']").innerText = html;
                } else {
                  (0, _util.selector)("[data-id='" + tem + "']").innerHTML = html;
                }
              } else if (renderWay === "text") {
                target.innerText = html;
              } else if (part) {
                var doc2 = document.createElement("div");
                doc2.innerHTML = html;
                var partHtml = doc2.querySelector(part).outerHTML;
                (0, _morphdom2.default)(target.querySelector(part), partHtml);
              } else {
                (0, _morphdom2.default)(target, "<div data-id='" + tem + "'>" + html + "</div>");
              }
              var template2 = _this5.atemplate.find(function(item) {
                return item.id === tem;
              });
              if (!template2.binded) {
                template2.binded = true;
                _this5.addDataBind((0, _util.selector)("[data-id='" + tem + "']"));
                _this5.addActionBind((0, _util.selector)("[data-id='" + tem + "']"));
              }
            };
            for (var i = 0, n = templates.length; i < n; i += 1) {
              _loop(i);
            }
            this.updateBindingData(part);
            if (this.onUpdated) {
              this.onUpdated(part);
            }
            return this;
          }
        }, {
          key: "updateBindingData",
          value: function updateBindingData(part) {
            var _this6 = this;
            var templates = this.templates;
            for (var i = 0, n = templates.length; i < n; i += 1) {
              var temp = templates[i];
              var _template = (0, _util.selector)("[data-id='" + temp + "']");
              if (part) {
                _template = _template.querySelector(part);
              }
              var binds = _template.querySelectorAll("[data-bind]");
              [].forEach.call(binds, function(item) {
                var data = _this6.getDataByString(item.getAttribute("data-bind"));
                if (item.getAttribute("type") === "checkbox" || item.getAttribute("type") === "radio") {
                  if (data === item.value) {
                    item.checked = true;
                  }
                } else {
                  item.value = data;
                }
              });
              var onewaybinds = _template.querySelectorAll("[data-bind-oneway]");
              [].forEach.call(onewaybinds, function(item) {
                var data = _this6.getDataByString(item.getAttribute("data-bind-oneway"));
                if (item.getAttribute("type") === "checkbox" || item.getAttribute("type") === "radio") {
                  if (data === item.value) {
                    item.checked = true;
                  }
                } else {
                  item.value = data;
                }
              });
            }
            return this;
          }
        }, {
          key: "applyMethod",
          value: function applyMethod(method) {
            var _method2;
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return (_method2 = this.method)[method].apply(_method2, args);
          }
        }, {
          key: "getComputedProp",
          value: function getComputedProp(prop) {
            return this.data[prop].apply(this);
          }
        }, {
          key: "remove",
          value: function remove(path) {
            var object = this.data;
            var stack = path.split(".");
            while (stack.length > 1) {
              object = object[stack.shift()];
            }
            var shift = stack.shift();
            if (shift.match(/^\d+$/)) {
              object.splice(Number(shift), 1);
            } else {
              delete object[shift];
            }
            return this;
          }
        }]);
        return aTemplate2;
      }();
      exports2.default = aTemplate;
      module2.exports = exports2["default"];
    })(lib, lib.exports);
    return lib.exports;
  }
  var libExports = requireLib();
  const ATemplate = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
  const isSmartPhone = () => {
    const agent = navigator.userAgent;
    if (agent.indexOf("iPhone") > 0 || agent.indexOf("iPad") > 0 || agent.indexOf("ipod") > 0 || agent.indexOf("Android") > 0) {
      return true;
    } else {
      return false;
    }
  };
  function deepExtend(out, ...args) {
    out = out || {};
    for (let i = 0; i < args.length; i++) {
      const obj = args[i];
      if (!obj) {
        continue;
      }
      for (const key in obj) {
        if (Object.hasOwn(obj, key)) {
          if (typeof obj[key] === "object")
            out[key] = deepExtend(out[key], obj[key]);
          else out[key] = obj[key];
        }
      }
    }
    return out;
  }
  const extend = deepExtend;
  const triggerEvent = (el, eventName, options) => {
    let event2;
    if (window.CustomEvent) {
      event2 = new CustomEvent(eventName, { cancelable: true });
    } else {
      event2 = document.createEvent("CustomEvent");
      event2.initCustomEvent(eventName, false, false, options);
    }
    el.dispatchEvent(event2);
  };
  const parseQuery = (query) => {
    var s = query.split("&"), data = {}, i = 0, iz = s.length, param, key, value;
    for (; i < iz; i++) {
      param = s[i].split("=");
      if (param[0] !== void 0) {
        key = param[0];
        value = param[1] !== void 0 ? param.slice(1).join("=") : key;
        data[key] = decodeURIComponent(value);
      }
    }
    return data;
  };
  const getViewPos = (element) => {
    return {
      left: element.getBoundingClientRect().left,
      top: element.getBoundingClientRect().top
    };
  };
  const removeElement = (element) => {
    if (element?.parentNode) {
      element.parentNode.removeChild(element);
    }
  };
  const append = (element, string) => {
    const div = document.createElement("div");
    div.innerHTML = string;
    while (div.children.length > 0) {
      element.appendChild(div.children[0]);
    }
  };
  const addClass = (element, className) => {
    if (element.classList) {
      element.classList.add(className);
    } else {
      element.className += ` ${className}`;
    }
  };
  const removeClass = (element, className) => {
    if (element.classList) {
      element.classList.remove(className);
    } else {
      element.className = element.className.replace(
        new RegExp(`(^|\\b)${className.split(" ").join("|")}(\\b|$)`, "gi"),
        " "
      );
    }
  };
  const getBrowser = () => {
    const ua = window.navigator.userAgent.toLowerCase();
    const ver = window.navigator.appVersion.toLowerCase();
    let name = "unknown";
    if (ua.indexOf("msie") !== -1) {
      if (ver.indexOf("msie 6.") !== -1) {
        name = "ie6";
      } else if (ver.indexOf("msie 7.") !== -1) {
        name = "ie7";
      } else if (ver.indexOf("msie 8.") !== -1) {
        name = "ie8";
      } else if (ver.indexOf("msie 9.") !== -1) {
        name = "ie9";
      } else if (ver.indexOf("msie 10.") !== -1) {
        name = "ie10";
      } else {
        name = "ie";
      }
    } else if (ua.indexOf("trident/7") !== -1) {
      name = "ie11";
    } else if (ua.indexOf("chrome") !== -1) {
      name = "chrome";
    } else if (ua.indexOf("safari") !== -1) {
      name = "safari";
    } else if (ua.indexOf("opera") !== -1) {
      name = "opera";
    } else if (ua.indexOf("firefox") !== -1) {
      name = "firefox";
    }
    return name;
  };
  const isOldIE = () => {
    const browser = getBrowser();
    if (browser.indexOf("ie") !== -1) {
      if (parseInt(browser.replace(/[^0-9]/g, "")) <= 10) {
        return true;
      }
    }
    return false;
  };
  const template = `<div class="\\{classNames.smartPhoto\\}"<!-- BEGIN hide:exist --> aria-hidden="true"<!-- END hide:exist --><!-- BEGIN hide:empty --> aria-hidden="false"<!-- END hide:empty --> role="dialog">
	<div class="\\{classNames.smartPhotoBody\\}">
		<div class="\\{classNames.smartPhotoInner\\}">
			   <div class="\\{classNames.smartPhotoHeader\\}">
					<span class="\\{classNames.smartPhotoCount\\}">{currentIndex}[increment]/{total}</span>
					<span class="\\{classNames.smartPhotoCaption\\}" aria-live="polite" tabindex="-1"><!-- BEGIN groupItems:loop --><!-- \\BEGIN currentIndex:touch#{index} -->{caption}<!-- \\END currentIndex:touch#{index} --><!-- END groupItems:loop --></span>
					<button class="\\{classNames.smartPhotoDismiss\\}" data-action-click="hidePhoto()"><span class="smartphoto-sr-only">\\{message.closeDialog\\}</span></button>
				</div>
				<div class="\\{classNames.smartPhotoContent\\}"<!-- BEGIN isSmartPhone:exist --> data-action-touchstart="beforeDrag" data-action-touchmove="onDrag" data-action-touchend="afterDrag(false)"<!-- END isSmartPhone:exist --><!-- BEGIN isSmartPhone:empty --> data-action-click="hidePhoto()"<!-- END isSmartPhone:empty -->>
				</div>
				<ul style="transform:translate({translateX}[round]px,{translateY}[round]px);" class="\\{classNames.smartPhotoList\\}<!-- BEGIN onMoveClass:exist --> \\{classNames.smartPhotoListOnMove\\}<!-- END onMoveClass:exist -->">
					<!-- BEGIN groupItems:loop -->
					<li style="transform:translate({translateX}[round]px,{translateY}[round]px);" class="<!-- \\BEGIN currentIndex:touch#{index} -->current<!-- \\END currentIndex:touch#{index} -->">
						<!-- BEGIN processed:exist -->
						<div style="transform:translate({x}[round]px,{y}[round]px) scale({scale});" class="\\\\{classNames.smartPhotoImgWrap\\\\}"<!-- \\BEGIN isSmartPhone:empty --> data-action-mousemove="onDrag" data-action-mousedown="beforeDrag" data-action-mouseup="afterDrag"<!-- \\END isSmartPhone:empty --><!-- \\BEGIN isSmartPhone:exist --> data-action-touchstart="beforeDrag" data-action-touchmove="onDrag" data-action-touchend="afterDrag"<!-- \\END isSmartPhone:exist -->>
							<img style="<!-- \\BEGIN currentIndex:touch#{index} -->transform:translate(\\{photoPosX\\}[virtualPos]px,\\{photoPosY\\}[virtualPos]px) scale(\\{scaleSize\\});<!-- \\END currentIndex:touch#{index} -->width:{width}px;" src="{src}" class="\\\\{classNames.smartPhotoImg\\\\}<!-- \\BEGIN scale:exist -->  \\\\{classNames.smartPhotoImgOnMove\\\\}<!-- \\END scale:exist --><!-- \\BEGIN elastic:exist --> \\\\{classNames.smartPhotoImgElasticMove\\\\}<!-- \\END elastic:exist --><!-- \\BEGIN appear:exist --> active<!-- \\END appear:exist -->" ondragstart="return false;">
						</div>
						<!-- END processed:exist -->
						<!-- BEGIN processed:empty -->
						<div class="\\\\{classNames.smartPhotoLoaderWrap\\\\}">
							<span class="\\\\{classNames.smartPhotoLoader\\\\}"></span>
						</div>
						<!-- END processed:empty -->
					</li>
					<!-- END groupItems:loop -->
				</ul>
				<!-- BEGIN arrows:exist -->
				<ul class="\\{classNames.smartPhotoArrows\\}"<!-- BEGIN hideUi:exist --> aria-hidden="true"<!-- END hideUi:exist --><!-- BEGIN hideUi:exist --> aria-hidden="false"<!-- END hideUi:exist -->>
					<li class="\\{classNames.smartPhotoArrowLeft\\}<!-- BEGIN isSmartPhone:exist --> \\{classNames.smartPhotoArrowHideIcon\\}<!-- END isSmartPhone:exist -->"<!-- BEGIN showPrevArrow:empty --> aria-hidden="true"<!-- END showPrevArrow:empty -->><a href="#" data-action-click="gotoSlide({prev})" role="button"><span class="smartphoto-sr-only">\\{message.gotoPrevImage\\}</span></a></li>
					<li class="\\{classNames.smartPhotoArrowRight\\}<!-- BEGIN isSmartPhone:exist --> \\{classNames.smartPhotoArrowHideIcon\\}<!-- END isSmartPhone:exist -->"<!-- BEGIN showNextArrow:empty --> aria-hidden="true"<!-- END showNextArrow:empty -->><a href="#" data-action-click="gotoSlide({next})" role="button"><span class="smartphoto-sr-only">\\{message.gotoNextImage\\}</span></a></li>
				</ul>
				<!-- END arrows:exist -->
				<!-- BEGIN nav:exist -->
				<nav class="\\{classNames.smartPhotoNav\\}"<!-- BEGIN hideUi:exist --> aria-hidden="true"<!-- END hideUi:exist --><!-- BEGIN hideUi:exist --> aria-hidden="false"<!-- END hideUi:exist -->>
					<ul>
						<!-- BEGIN groupItems:loop -->
						<li><a href="#" data-action-click="gotoSlide({index})" class="<!-- \\BEGIN currentIndex:touch#{index} -->current<!-- \\END currentIndex:touch#{index} -->" style="background-image:url('{thumb}');" role="button"><span class="smartphoto-sr-only">go to {caption}</span></a></li>
						<!-- END groupItems:loop -->
					</ul>
				</nav>
				<!-- END nav:exist -->
		</div>
		<!-- BEGIN appearEffect:exist -->
		<img src=\\{appearEffect.img\\}
		class="\\{classNames.smartPhotoImgClone\\}"
		style="width:\\{appearEffect.width\\}px;height:\\{appearEffect.height\\}px;transform:translate(\\{appearEffect.left\\}px,\\{appearEffect.top\\}px) scale(1)" />
		<!-- END appearEffect:exist -->
	</div>
</div>
`;
  const defaults = {
    classNames: {
      smartPhoto: "smartphoto",
      smartPhotoClose: "smartphoto-close",
      smartPhotoBody: "smartphoto-body",
      smartPhotoInner: "smartphoto-inner",
      smartPhotoContent: "smartphoto-content",
      smartPhotoImg: "smartphoto-img",
      smartPhotoImgOnMove: "smartphoto-img-onmove",
      smartPhotoImgElasticMove: "smartphoto-img-elasticmove",
      smartPhotoImgWrap: "smartphoto-img-wrap",
      smartPhotoArrows: "smartphoto-arrows",
      smartPhotoNav: "smartphoto-nav",
      smartPhotoArrowRight: "smartphoto-arrow-right",
      smartPhotoArrowLeft: "smartphoto-arrow-left",
      smartPhotoArrowHideIcon: "smartphoto-arrow-hide",
      smartPhotoImgLeft: "smartphoto-img-left",
      smartPhotoImgRight: "smartphoto-img-right",
      smartPhotoList: "smartphoto-list",
      smartPhotoListOnMove: "smartphoto-list-onmove",
      smartPhotoHeader: "smartphoto-header",
      smartPhotoCount: "smartphoto-count",
      smartPhotoCaption: "smartphoto-caption",
      smartPhotoDismiss: "smartphoto-dismiss",
      smartPhotoLoader: "smartphoto-loader",
      smartPhotoLoaderWrap: "smartphoto-loader-wrap",
      smartPhotoImgClone: "smartphoto-img-clone"
    },
    message: {
      gotoNextImage: "go to the next image",
      gotoPrevImage: "go to the previous image",
      closeDialog: "close the image dialog"
    },
    arrows: true,
    nav: true,
    showAnimation: true,
    verticalGravity: false,
    useOrientationApi: false,
    useHistoryApi: true,
    swipeTopToClose: false,
    swipeBottomToClose: true,
    swipeOffset: 100,
    headerHeight: 60,
    footerHeight: 60,
    forceInterval: 10,
    registance: 0.5,
    loadOffset: 2,
    resizeStyle: "fit",
    lazyAttribute: "data-src"
  };
  class SmartPhoto extends ATemplate {
    constructor(selector, settings) {
      super();
      this.data = extend({}, defaults, settings);
      this.data.currentIndex = 0;
      this.data.oldIndex = 0;
      this.data.hide = true;
      this.data.group = {};
      this.data.scaleSize = 1;
      this.data.scale = false;
      this.pos = { x: 0, y: 0 };
      this.data.photoPosX = 0;
      this.data.photoPosY = 0;
      this.handlers = [];
      this.convert = {
        increment: this.increment,
        virtualPos: this.virtualPos,
        round: this.round
      };
      this.data.groupItems = this.groupItems;
      this.elements = typeof selector === "string" ? document.querySelectorAll(selector) : selector;
      const date = /* @__PURE__ */ new Date();
      this.tapSecond = date.getTime();
      this.onListMove = false;
      this.clicked = false;
      this.id = this._getUniqId();
      this.vx = 0;
      this.vy = 0;
      this.data.appearEffect = null;
      this.addTemplate(this.id, template);
      this.data.isSmartPhone = this._isSmartPhone();
      const body = document.querySelector("body");
      append(body, `<div data-id='${this.id}'></div>`);
      [].forEach.call(this.elements, (element) => {
        this.addNewItem(element);
      });
      this.update();
      const currentItem = this._getCurrentItemByHash();
      if (currentItem) {
        triggerEvent(currentItem.element, "click");
      }
      this.interval = setInterval(() => {
        this._doAnim();
      }, this.data.forceInterval);
      if (!this.data.isSmartPhone) {
        const resizeHandler = () => {
          if (!this.groupItems()) {
            return;
          }
          this._resetTranslate();
          this._setPosByCurrentIndex();
          this._setSizeByScreen();
          this.update();
        };
        const keydownHandler = (e) => {
          const code = e.keyCode || e.which;
          if (this.data.hide === true) {
            return;
          }
          if (code === 37) {
            this.gotoSlide(this.data.prev);
          } else if (code === 39) {
            this.gotoSlide(this.data.next);
          } else if (code === 27) {
            this.hidePhoto();
          }
        };
        window.addEventListener("resize", resizeHandler);
        window.addEventListener("keydown", keydownHandler);
        this._registerRemoveEvent(window, "resize", resizeHandler);
        this._registerRemoveEvent(window, "keydown", keydownHandler);
        return;
      }
      const orientationChangeHandler = () => {
        if (!this.groupItems()) {
          return;
        }
        this._resetTranslate();
        this._setPosByCurrentIndex();
        this._setHashByCurrentIndex();
        this._setSizeByScreen();
        this.update();
        const prevWidth = this._getWindowWidth();
        const timeout = 500;
        const photoResizeAfterWindowSizeChange = (time) => {
          new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, 25);
          }).then(() => {
            if (prevWidth !== this._getWindowWidth()) {
              this._resetTranslate();
              this._setPosByCurrentIndex();
              this._setHashByCurrentIndex();
              this._setSizeByScreen();
              this.update();
            } else if (time <= timeout) {
              photoResizeAfterWindowSizeChange(time + 25);
            }
          });
        };
        photoResizeAfterWindowSizeChange(0);
      };
      window.addEventListener("orientationchange", orientationChangeHandler);
      this._registerRemoveEvent(
        window,
        "orientationchange",
        orientationChangeHandler
      );
      if (!this.data.useOrientationApi) {
        return;
      }
      const deviceorientationHandler = (e) => {
        const { orientation } = window;
        if (!e || !e.gamma || this.data.appearEffect) {
          return;
        }
        if (!this.isBeingZoomed && !this.photoSwipable && !this.data.elastic && this.data.scale) {
          if (orientation === 0) {
            this._calcGravity(e.gamma, e.beta);
          } else if (orientation === 90) {
            this._calcGravity(e.beta, e.gamma);
          } else if (orientation === -90) {
            this._calcGravity(-e.beta, -e.gamma);
          } else if (orientation === 180) {
            this._calcGravity(-e.gamma, -e.beta);
          }
        }
      };
      window.addEventListener("deviceorientation", deviceorientationHandler);
      this._registerRemoveEvent(
        window,
        "deviceorientation",
        deviceorientationHandler
      );
    }
    on(event2, fn) {
      const photo = this._getElementByClass(this.data.classNames.smartPhoto);
      const handler = (e) => {
        fn.call(photo, e);
      };
      photo.addEventListener(event2, handler);
      this._registerRemoveEvent(photo, event2, handler);
    }
    _registerRemoveEvent(target, event2, handler) {
      this.handlers.push({
        target,
        event: event2,
        handler
      });
    }
    destroy() {
      this.handlers.forEach((handler) => {
        handler.target.removeEventListener(handler.event, handler.handler);
      });
      const wrapper = document.querySelector(`[data-id="${this.id}"]`);
      removeElement(wrapper);
      clearInterval(this.interval);
      this.removeTemplateEvents();
    }
    increment(item) {
      return item + 1;
    }
    round(number) {
      return Math.round(number);
    }
    virtualPos(pos) {
      pos = parseInt(pos, 10);
      const item = this._getSelectedItem();
      return pos / item.scale / this.data.scaleSize;
    }
    groupItems() {
      return this.data.group[this.data.currentGroup];
    }
    _resetTranslate() {
      const items = this.groupItems();
      items.forEach((item, index) => {
        item.translateX = this._getWindowWidth() * index;
      });
    }
    addNewItem(element) {
      const groupId = element.getAttribute("data-group") || "nogroup";
      const { group } = this.data;
      if (groupId === "nogroup") {
        element.setAttribute("data-group", "nogroup");
      }
      if (!group[groupId]) {
        group[groupId] = [];
      }
      const index = group[groupId].length;
      const body = document.querySelector("body");
      const src = element.getAttribute("href");
      const img = element.querySelector("img");
      let thumb = src;
      if (img) {
        if (img.getAttribute(this.data.lazyAttribute)) {
          thumb = img.getAttribute(this.data.lazyAttribute);
        } else if (img.currentSrc) {
          thumb = img.currentSrc;
        } else {
          thumb = img.src;
        }
      }
      const item = {
        src,
        thumb,
        caption: element.getAttribute("data-caption"),
        groupId,
        translateX: this._getWindowWidth() * index,
        index,
        translateY: 0,
        width: 50,
        height: 50,
        id: element.getAttribute("data-id") || index,
        loaded: false,
        processed: false,
        element
      };
      group[groupId].push(item);
      this.data.currentGroup = groupId;
      const id = element.getAttribute("data-id");
      if (!id) {
        element.setAttribute("data-id", index);
      }
      element.setAttribute("data-index", index);
      const clickHandler = (event2) => {
        event2.preventDefault();
        this.data.currentGroup = element.getAttribute("data-group");
        this.data.currentIndex = parseInt(element.getAttribute("data-index"), 10);
        this._setHashByCurrentIndex();
        const currentItem = this._getSelectedItem();
        if (currentItem.loaded) {
          this._initPhoto();
          this.addAppearEffect(element, currentItem);
          this.clicked = true;
          this.update();
          body.style.overflow = "hidden";
          this._fireEvent("open");
        } else {
          this._loadItem(currentItem).then(() => {
            this._initPhoto();
            this.addAppearEffect(element, currentItem);
            this.clicked = true;
            this.update();
            body.style.overflow = "hidden";
            this._fireEvent("open");
          });
        }
      };
      element.addEventListener("click", clickHandler);
      this._registerRemoveEvent(element, "click", clickHandler);
    }
    _initPhoto() {
      this.data.total = this.groupItems().length;
      this.data.hide = false;
      this.data.photoPosX = 0;
      this.data.photoPosY = 0;
      this._setPosByCurrentIndex();
      this._setSizeByScreen();
      this.setArrow();
      if (this.data.resizeStyle === "fill" && this.data.isSmartPhone) {
        this.data.scale = true;
        this.data.hideUi = true;
        this.data.scaleSize = this._getScaleBoarder();
      }
    }
    onUpdated() {
      if (this.data.appearEffect?.once) {
        this.data.appearEffect.once = false;
        this.execEffect().then(() => {
          this.data.appearEffect = null;
          this.data.appear = true;
          this.update();
        });
      }
      if (this.clicked) {
        this.clicked = false;
        const { classNames } = this.data;
        const caption = this._getElementByClass(classNames.smartPhotoCaption);
        caption.focus();
      }
    }
    execEffect() {
      return new Promise((resolve) => {
        if (isOldIE()) {
          resolve();
        }
        const { appearEffect, classNames } = this.data;
        const effect = this._getElementByClass(classNames.smartPhotoImgClone);
        const handler = () => {
          effect.removeEventListener("transitionend", handler, true);
          resolve();
        };
        effect.addEventListener("transitionend", handler, true);
        setTimeout(() => {
          effect.style.transform = `translate(${appearEffect.afterX}px, ${appearEffect.afterY}px) scale(${appearEffect.scale})`;
        }, 10);
      });
    }
    addAppearEffect(element, item) {
      if (this.data.showAnimation === false) {
        this.data.appear = true;
        return;
      }
      const img = element.querySelector("img");
      const pos = getViewPos(img);
      const appear = {};
      let scale = 1;
      appear.width = img.offsetWidth;
      appear.height = img.offsetHeight;
      appear.top = pos.top;
      appear.left = pos.left;
      appear.once = true;
      if (img.getAttribute(this.data.lazyAttribute)) {
        appear.img = img.getAttribute(this.data.lazyAttribute);
      } else {
        appear.img = item.src;
      }
      const toX = this._getWindowWidth();
      const toY = this._getWindowHeight();
      const screenY = toY - this.data.headerHeight - this.data.footerHeight;
      if (this.data.resizeStyle === "fill" && this.data.isSmartPhone) {
        if (img.offsetWidth > img.offsetHeight) {
          scale = toY / img.offsetHeight;
        } else {
          scale = toX / img.offsetWidth;
        }
      } else {
        if (appear.width >= appear.height) {
          if (item.height < screenY) {
            scale = item.width / appear.width;
          } else {
            scale = screenY / appear.height;
          }
        } else if (appear.height > appear.width) {
          if (item.height < screenY) {
            scale = item.height / appear.height;
          } else {
            scale = screenY / appear.height;
          }
        }
        if (appear.width * scale > toX) {
          scale = toX / appear.width;
        }
      }
      const x = (scale - 1) / 2 * img.offsetWidth + (toX - img.offsetWidth * scale) / 2;
      const y = (scale - 1) / 2 * img.offsetHeight + (toY - img.offsetHeight * scale) / 2;
      appear.afterX = x;
      appear.afterY = y;
      appear.scale = scale;
      this.data.appearEffect = appear;
    }
    hidePhoto(dir = "bottom") {
      this.data.hide = true;
      this.data.appear = false;
      this.data.appearEffect = null;
      this.data.hideUi = false;
      this.data.scale = false;
      this.data.scaleSize = 1;
      const scrollX = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
      const scrollY = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
      const body = document.querySelector("body");
      if (window.location.hash) {
        this._setHash("");
      }
      window.scroll(scrollX, scrollY);
      this._doHideEffect(dir).then(() => {
        this.update();
        body.style.overflow = "";
        this._fireEvent("close");
      });
    }
    _doHideEffect(dir) {
      return new Promise((resolve) => {
        if (isOldIE()) {
          resolve();
        }
        const { classNames } = this.data;
        const photo = this._getElementByClass(classNames.smartPhoto);
        const img = this._getElementByQuery(
          `.current .${classNames.smartPhotoImg}`
        );
        const height = this._getWindowHeight();
        const handler = () => {
          photo.removeEventListener("transitionend", handler, true);
          resolve();
        };
        photo.style.opacity = 0;
        if (dir === "bottom") {
          img.style.transform = `translateY(${height}px)`;
        } else if (dir === "top") {
          img.style.transform = `translateY(-${height}px)`;
        }
        photo.addEventListener("transitionend", handler, true);
      });
    }
    _getElementByClass(className) {
      return document.querySelector(`[data-id="${this.id}"] .${className}`);
    }
    _getElementByQuery(query) {
      return document.querySelector(`[data-id="${this.id}"] ${query}`);
    }
    _getTouchPos() {
      let x = 0;
      let y = 0;
      const e = typeof event === "undefined" ? this.e : event;
      if (this._isTouched(e)) {
        x = e.touches[0].pageX;
        y = e.touches[0].pageY;
      } else if (e.pageX) {
        x = e.pageX;
        y = e.pageY;
      }
      return { x, y };
    }
    _getGesturePos(e) {
      const touches = e.touches;
      return [
        { x: touches[0].pageX, y: touches[0].pageY },
        { x: touches[1].pageX, y: touches[1].pageY }
      ];
    }
    _setPosByCurrentIndex() {
      const items = this.groupItems();
      const moveX = -1 * items[this.data.currentIndex].translateX;
      this.pos.x = moveX;
      setTimeout(() => {
        this.data.translateX = moveX;
        this.data.translateY = 0;
        this._listUpdate();
      }, 1);
    }
    _setHashByCurrentIndex() {
      const scrollX = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
      const scrollY = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
      const items = this.groupItems();
      const id = items[this.data.currentIndex].id;
      const group = this.data.currentGroup;
      const hash = `group=${group}&photo=${id}`;
      this._setHash(hash);
      window.scroll(scrollX, scrollY);
    }
    _setHash(hash) {
      if (!window.history?.pushState || !this.data.useHistoryApi) {
        return;
      }
      if (hash) {
        window.history.replaceState(
          null,
          null,
          `${location.pathname}${location.search}#${hash}`
        );
      } else {
        window.history.replaceState(
          null,
          null,
          `${location.pathname}${location.search}`
        );
      }
    }
    _getCurrentItemByHash() {
      const group = this.data.group;
      const hash = location.hash.substr(1);
      const hashObj = parseQuery(hash);
      let currentItem = null;
      const getCurrentItem = (item) => {
        if (hashObj.group === item.groupId && hashObj.photo === item.id) {
          currentItem = item;
        }
      };
      Object.keys(group).forEach((key) => {
        group[key].forEach(getCurrentItem);
      });
      return currentItem;
    }
    _loadItem(item) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          item.width = img.width;
          item.height = img.height;
          item.loaded = true;
          resolve();
        };
        img.onerror = () => {
          resolve();
        };
        img.src = item.src;
      });
    }
    _getItemByIndex(index) {
      const { data } = this;
      if (data.group[data.currentGroup][index]) {
        return data.group[data.currentGroup][index];
      }
      return null;
    }
    _loadNeighborItems() {
      const index = this.data.currentIndex;
      const { loadOffset } = this.data;
      const from = index - loadOffset;
      const to = index + loadOffset;
      const promises = [];
      for (let i = from; i < to; i++) {
        const item = this._getItemByIndex(i);
        if (item && !item.loaded) {
          promises.push(this._loadItem(item));
        }
      }
      if (promises.length) {
        Promise.all(promises).then(() => {
          this._initPhoto();
          this.update();
        });
      }
    }
    _setSizeByScreen() {
      const windowX = this._getWindowWidth();
      const windowY = this._getWindowHeight();
      const headerHeight = this.data.headerHeight;
      const footerHeight = this.data.footerHeight;
      const screenY = windowY - (headerHeight + footerHeight);
      const items = this.groupItems();
      items.forEach((item) => {
        if (!item.loaded) {
          return;
        }
        item.processed = true;
        item.scale = screenY / item.height;
        if (item.height < screenY) {
          item.scale = 1;
        }
        item.x = (item.scale - 1) / 2 * item.width + (windowX - item.width * item.scale) / 2;
        item.y = (item.scale - 1) / 2 * item.height + (windowY - item.height * item.scale) / 2;
        if (item.width * item.scale > windowX) {
          item.scale = windowX / item.width;
          item.x = (item.scale - 1) / 2 * item.width;
        }
      });
    }
    _slideList() {
      this.data.scaleSize = 1;
      this.isBeingZoomed = false;
      this.data.hideUi = false;
      this.data.scale = false;
      this.data.photoPosX = 0;
      this.data.photoPosY = 0;
      this.data.onMoveClass = true;
      this._setPosByCurrentIndex();
      this._setHashByCurrentIndex();
      this._setSizeByScreen();
      setTimeout(() => {
        const item = this._getSelectedItem();
        this.data.onMoveClass = false;
        this.setArrow();
        this.update();
        if (this.data.oldIndex !== this.data.currentIndex) {
          this._fireEvent("change");
        }
        this.data.oldIndex = this.data.currentIndex;
        this._loadNeighborItems();
        if (!item.loaded) {
          this._loadItem(item).then(() => {
            this._initPhoto();
            this.update();
          });
        }
      }, 200);
    }
    gotoSlide(index) {
      if (this.e?.preventDefault) {
        this.e.preventDefault();
      }
      this.data.currentIndex = parseInt(index, 10);
      if (!this.data.currentIndex) {
        this.data.currentIndex = 0;
      }
      this._slideList();
    }
    setArrow() {
      const items = this.groupItems();
      const length = items.length;
      const next = this.data.currentIndex + 1;
      const prev = this.data.currentIndex - 1;
      this.data.showNextArrow = false;
      this.data.showPrevArrow = false;
      if (next !== length) {
        this.data.next = next;
        this.data.showNextArrow = true;
      }
      if (prev !== -1) {
        this.data.prev = prev;
        this.data.showPrevArrow = true;
      }
    }
    beforeDrag() {
      if (this._isGestured(this.e)) {
        this.beforeGesture();
        return;
      }
      this.isBeingZoomed = false;
      if (this.data.scale) {
        this.beforePhotoDrag();
        return;
      }
      const pos = this._getTouchPos();
      this.isSwipable = true;
      this.dragStart = true;
      this.firstPos = pos;
      this.oldPos = pos;
    }
    afterDrag() {
      const items = this.groupItems();
      const date = /* @__PURE__ */ new Date();
      const tapSecond = date.getTime();
      const offset = this.tapSecond - tapSecond;
      let swipeWidth = 0;
      let swipeHeight = 0;
      this.isSwipable = false;
      this.onListMove = false;
      if (this.oldPos) {
        swipeWidth = this.oldPos.x - this.firstPos.x;
        swipeHeight = this.oldPos.y - this.firstPos.y;
      }
      if (this.isBeingZoomed) {
        this.afterGesture();
        return;
      }
      if (this.data.scale) {
        this.afterPhotoDrag();
        return;
      } else if (!isSmartPhone() && swipeWidth === 0 && swipeHeight === 0) {
        this.zoomPhoto();
        return;
      }
      if (Math.abs(offset) <= 500 && swipeWidth === 0 && swipeHeight === 0) {
        this.e.preventDefault();
        this.zoomPhoto();
        return;
      }
      this.tapSecond = tapSecond;
      this._fireEvent("swipeend");
      if (this.moveDir === "horizontal") {
        if (swipeWidth >= this.data.swipeOffset && this.data.currentIndex !== 0) {
          this.data.currentIndex -= 1;
        } else if (swipeWidth <= -this.data.swipeOffset && this.data.currentIndex !== items.length - 1) {
          this.data.currentIndex += 1;
        }
        this._slideList();
      }
      if (this.moveDir === "vertical") {
        if (this.data.swipeBottomToClose && swipeHeight >= this.data.swipeOffset) {
          this.hidePhoto("bottom");
        } else if (this.data.swipeTopToClose && swipeHeight <= -this.data.swipeOffset) {
          this.hidePhoto("top");
        } else {
          this.data.translateY = 0;
          this._slideList();
        }
      }
    }
    onDrag() {
      this.e.preventDefault();
      if (this._isGestured(this.e) && this.onListMove === false) {
        this.onGesture();
        return;
      }
      if (this.isBeingZoomed) {
        return;
      }
      if (this.data.scale) {
        this.onPhotoDrag();
        return;
      }
      if (!this.isSwipable) {
        return;
      }
      const pos = this._getTouchPos();
      const x = pos.x - this.oldPos.x;
      const y = pos.y - this.firstPos.y;
      if (this.dragStart) {
        this._fireEvent("swipestart");
        this.dragStart = false;
        if (Math.abs(x) > Math.abs(y)) {
          this.moveDir = "horizontal";
        } else {
          this.moveDir = "vertical";
        }
      }
      if (this.moveDir === "horizontal") {
        this.pos.x += x;
        this.data.translateX = this.pos.x;
      } else {
        this.data.translateY = y;
      }
      this.onListMove = true;
      this.oldPos = pos;
      this._listUpdate();
    }
    zoomPhoto() {
      this.data.hideUi = true;
      this.data.scaleSize = this._getScaleBoarder();
      if (this.data.scaleSize <= 1) {
        return;
      }
      this.data.photoPosX = 0;
      this.data.photoPosY = 0;
      this._photoUpdate();
      setTimeout(() => {
        this.data.scale = true;
        this._photoUpdate();
        this._fireEvent("zoomin");
      }, 300);
    }
    zoomOutPhoto() {
      this.data.scaleSize = 1;
      this.isBeingZoomed = false;
      this.data.hideUi = false;
      this.data.scale = false;
      this.data.photoPosX = 0;
      this.data.photoPosY = 0;
      this._photoUpdate();
      this._fireEvent("zoomout");
    }
    beforePhotoDrag() {
      const pos = this._getTouchPos();
      this.photoSwipable = true;
      if (!this.data.photoPosX) {
        this.data.photoPosX = 0;
      }
      if (!this.data.photoPosY) {
        this.data.photoPosY = 0;
      }
      this.oldPhotoPos = pos;
      this.firstPhotoPos = pos;
    }
    onPhotoDrag() {
      if (!this.photoSwipable) {
        return;
      }
      this.e.preventDefault();
      const pos = this._getTouchPos();
      const x = pos.x - this.oldPhotoPos.x;
      const y = pos.y - this.oldPhotoPos.y;
      const moveX = this._round(this.data.scaleSize * x, 6);
      const moveY = this._round(this.data.scaleSize * y, 6);
      if (typeof moveX === "number") {
        this.data.photoPosX += moveX;
        this.photoVX = moveX;
      }
      if (typeof moveY === "number") {
        this.data.photoPosY += moveY;
        this.photoVY = moveY;
      }
      this.oldPhotoPos = pos;
      this._photoUpdate();
    }
    afterPhotoDrag() {
      if (this.oldPhotoPos.x === this.firstPhotoPos.x && this.photoSwipable) {
        this.photoSwipable = false;
        this.zoomOutPhoto();
      } else {
        this.photoSwipable = false;
        const item = this._getSelectedItem();
        const bound = this._makeBound(item);
        const offset = this.data.swipeOffset * this.data.scaleSize;
        let flagX = 0;
        let flagY = 0;
        if (this.data.photoPosX > bound.maxX) {
          flagX = -1;
        } else if (this.data.photoPosX < bound.minX) {
          flagX = 1;
        }
        if (this.data.photoPosY > bound.maxY) {
          flagY = -1;
        } else if (this.data.photoPosY < bound.minY) {
          flagY = 1;
        }
        if (this.data.photoPosX - bound.maxX > offset && this.data.currentIndex !== 0) {
          this.gotoSlide(this.data.prev);
          return;
        }
        if (bound.minX - this.data.photoPosX > offset && this.data.currentIndex + 1 !== this.data.total) {
          this.gotoSlide(this.data.next);
          return;
        }
        if (flagX === 0 && flagY === 0) {
          this.vx = this.photoVX / 5;
          this.vy = this.photoVY / 5;
        } else {
          this._registerElasticForce(flagX, flagY);
        }
      }
    }
    beforeGesture() {
      this._fireEvent("gesturestart");
      const pos = this._getGesturePos(this.e);
      const distance = this._getDistance(pos[0], pos[1]);
      this.isBeingZoomed = true;
      this.oldDistance = distance;
      this.data.scale = true;
      this.e.preventDefault();
    }
    onGesture() {
      const pos = this._getGesturePos(this.e);
      const distance = this._getDistance(pos[0], pos[1]);
      const size = (distance - this.oldDistance) / 100;
      const oldScaleSize = this.data.scaleSize;
      const posX = this.data.photoPosX;
      const posY = this.data.photoPosY;
      this.isBeingZoomed = true;
      this.data.scaleSize += this._round(size, 6);
      if (this.data.scaleSize < 0.2) {
        this.data.scaleSize = 0.2;
      }
      if (this.data.scaleSize < oldScaleSize) {
        this.data.photoPosX = (1 + this.data.scaleSize - oldScaleSize) * posX;
        this.data.photoPosY = (1 + this.data.scaleSize - oldScaleSize) * posY;
      }
      if (this.data.scaleSize < 1 || this.data.scaleSize > this._getScaleBoarder()) {
        this.data.hideUi = true;
      } else {
        this.data.hideUi = false;
      }
      this.oldDistance = distance;
      this.e.preventDefault();
      this._photoUpdate();
    }
    afterGesture() {
      if (this.data.scaleSize > this._getScaleBoarder()) {
        return;
      }
      this.data.photoPosX = 0;
      this.data.photoPosY = 0;
      this.data.scale = false;
      this.data.scaleSize = 1;
      this.data.hideUi = false;
      this._fireEvent("gestureend");
      this._photoUpdate();
    }
    _getForceAndTheta(vx, vy) {
      return {
        force: Math.sqrt(vx * vx + vy * vy),
        theta: Math.atan2(vy, vx)
      };
    }
    _getScaleBoarder() {
      const item = this._getSelectedItem();
      const windowWidth = this._getWindowWidth();
      const windowHeight = this._getWindowHeight();
      if (!isSmartPhone()) {
        return 1 / item.scale;
      }
      if (item.width > item.height) {
        return windowHeight / (item.height * item.scale);
      }
      return windowWidth / (item.width * item.scale);
    }
    _makeBound(item) {
      const width = item.width * item.scale * this.data.scaleSize;
      const height = item.height * item.scale * this.data.scaleSize;
      let minX;
      let minY;
      let maxX;
      let maxY;
      const windowWidth = this._getWindowWidth();
      const windowHeight = this._getWindowHeight();
      if (windowWidth > width) {
        maxX = (windowWidth - width) / 2;
        minX = -1 * maxX;
      } else {
        maxX = (width - windowWidth) / 2;
        minX = -1 * maxX;
      }
      if (windowHeight > height) {
        maxY = (windowHeight - height) / 2;
        minY = -1 * maxY;
      } else {
        maxY = (height - windowHeight) / 2;
        minY = -1 * maxY;
      }
      return {
        minX: this._round(minX, 6) * this.data.scaleSize,
        minY: this._round(minY, 6) * this.data.scaleSize,
        maxX: this._round(maxX, 6) * this.data.scaleSize,
        maxY: this._round(maxY, 6) * this.data.scaleSize
      };
    }
    _registerElasticForce(x, y) {
      const item = this._getSelectedItem();
      const bound = this._makeBound(item);
      this.data.elastic = true;
      if (x === 1) {
        this.data.photoPosX = bound.minX;
      } else if (x === -1) {
        this.data.photoPosX = bound.maxX;
      }
      if (y === 1) {
        this.data.photoPosY = bound.minY;
      } else if (y === -1) {
        this.data.photoPosY = bound.maxY;
      }
      this._photoUpdate();
      setTimeout(() => {
        this.data.elastic = false;
        this._photoUpdate();
      }, 300);
    }
    _getSelectedItem() {
      const data = this.data;
      const index = data.currentIndex;
      return data.group[data.currentGroup][index];
    }
    _getUniqId() {
      return (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
    }
    _getDistance(point1, point2) {
      const x = point1.x - point2.x;
      const y = point1.y - point2.y;
      return Math.sqrt(x * x + y * y);
    }
    _round(val, precision) {
      const digit = 10 ** precision;
      val *= digit;
      val = Math.round(val);
      val /= digit;
      return val;
    }
    _isTouched(e) {
      if (e?.touches) {
        return true;
      }
      return false;
    }
    _isGestured(e) {
      if (e?.touches && e.touches.length > 1) {
        return true;
      }
      return false;
    }
    _isSmartPhone() {
      const agent = navigator.userAgent;
      if (agent.indexOf("iPhone") > 0 || agent.indexOf("iPad") > 0 || agent.indexOf("ipod") > 0 || agent.indexOf("Android") > 0) {
        return true;
      }
      return false;
    }
    _calcGravity(gamma, beta) {
      if (gamma > 5 || gamma < -5) {
        this.vx += gamma * 0.05;
      }
      if (this.data.verticalGravity === false) {
        return;
      }
      if (beta > 5 || beta < -5) {
        this.vy += beta * 0.05;
      }
    }
    _photoUpdate() {
      const classNames = this.data.classNames;
      const current = this._getElementByQuery(".current");
      const img = current.querySelector(`.${classNames.smartPhotoImg}`);
      const nav = this._getElementByQuery(`.${classNames.smartPhotoNav}`);
      const arrows = this._getElementByQuery(`.${classNames.smartPhotoArrows}`);
      const photoPosX = this.virtualPos(this.data.photoPosX);
      const photoPosY = this.virtualPos(this.data.photoPosY);
      const scaleSize = this.data.scaleSize;
      const transform = `translate(${photoPosX}px,${photoPosY}px) scale(${scaleSize})`;
      img.style.transform = transform;
      if (this.data.scale) {
        addClass(img, classNames.smartPhotoImgOnMove);
      } else {
        removeClass(img, classNames.smartPhotoImgOnMove);
      }
      if (this.data.elastic) {
        addClass(img, classNames.smartPhotoImgElasticMove);
      } else {
        removeClass(img, classNames.smartPhotoImgElasticMove);
      }
      if (this.data.hideUi) {
        if (nav) {
          nav.setAttribute("aria-hidden", "true");
        }
        if (arrows) {
          arrows.setAttribute("aria-hidden", "true");
        }
      } else {
        if (nav) {
          nav.setAttribute("aria-hidden", "false");
        }
        if (arrows) {
          arrows.setAttribute("aria-hidden", "false");
        }
      }
    }
    _getWindowWidth() {
      if (document?.documentElement) {
        return document.documentElement.clientWidth;
      } else if (window?.innerWidth) {
        return window.innerWidth;
      }
      return 0;
    }
    _getWindowHeight() {
      if (document?.documentElement) {
        return document.documentElement.clientHeight;
      } else if (window?.innerHeight) {
        return window.innerHeight;
      }
      return 0;
    }
    _listUpdate() {
      const classNames = this.data.classNames;
      const list = this._getElementByQuery(`.${classNames.smartPhotoList}`);
      const transform = `translate(${this.data.translateX}px,${this.data.translateY}px)`;
      list.style.transform = transform;
      if (this.data.onMoveClass) {
        addClass(list, classNames.smartPhotoListOnMove);
      } else {
        removeClass(list, classNames.smartPhotoListOnMove);
      }
    }
    _fireEvent(eventName) {
      const photo = this._getElementByClass(this.data.classNames.smartPhoto);
      triggerEvent(photo, eventName);
    }
    _doAnim() {
      if (this.isBeingZoomed || this.isSwipable || this.photoSwipable || this.data.elastic || !this.data.scale) {
        return;
      }
      this.data.photoPosX += this.vx;
      this.data.photoPosY += this.vy;
      const item = this._getSelectedItem();
      const bound = this._makeBound(item);
      if (this.data.photoPosX < bound.minX) {
        this.data.photoPosX = bound.minX;
        this.vx *= -0.2;
      } else if (this.data.photoPosX > bound.maxX) {
        this.data.photoPosX = bound.maxX;
        this.vx *= -0.2;
      }
      if (this.data.photoPosY < bound.minY) {
        this.data.photoPosY = bound.minY;
        this.vy *= -0.2;
      } else if (this.data.photoPosY > bound.maxY) {
        this.data.photoPosY = bound.maxY;
        this.vy *= -0.2;
      }
      const power = this._getForceAndTheta(this.vx, this.vy);
      let force = power.force;
      const theta = power.theta;
      force -= this.data.registance;
      if (Math.abs(force) < 0.5) {
        return;
      }
      this.vx = Math.cos(theta) * force;
      this.vy = Math.sin(theta) * force;
      this._photoUpdate();
    }
  }
  return SmartPhoto;
});
